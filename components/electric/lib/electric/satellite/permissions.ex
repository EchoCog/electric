defmodule Electric.Satellite.Permissions do
  use Electric.Satellite.Protobuf

  alias Electric.Replication.Changes
  alias Electric.Satellite.Permissions.{Grant, Role, Scope, Transient}
  alias Electric.Satellite.Auth
  alias Electric.Satellite.SatPerms

  @moduledoc """
  Provides functions for validating writes from satellites and filtering reads from pg against a
  set of permissions.

  A `#{__MODULE__}` struct is generated from a set of protobuf permissions definitions -- a list of
  `#{SatPerms.Grant}` structs direct from the DDLX ingest, and a list of `#{SatPerms.Role}` structs
  generated by the DDLX assign triggers.

  The protobuf data is compiled into a set of lookup tables to make permissions checks as
  performant as possible.

  ## Key data structures

  - `Permissions.roles`: a map of `{relation(), privilege()} =>
  assigned_roles()` which allows for a quick retrieval of all grants and associated roles for a
  given action.

  - `%RoleGrant{}`: this struct holds a role and grant where the role provides the grant and the
    grant provides the rights.

  - `assigned_roles()`: A set of scoped and unscoped `RoleGrant` structs. "Unscoped" means that
    the role assignment applies globally and is not rooted on any element of the data.

  ## Validating writes

  The `validate_write/2` function takes a `Permissions` struct and a transaction and verifies that
  all the writes in the transaction are allowed according to the current permissions rules.

  If any change in the transaction fails the permissions check then the whole transaction is
  rejected.

  The permissions resolution process goes something like this:

  ### 1. Find RoleGrant instances for the change

  The `assigned_roles()` table is retrieved from the `Permissions.roles` attribute for the
  given change. This allows for quick verification that the user has some kind of permission to
  perform the action. If the `assigned_roles()` for a change is `nil` then we know immediately
  that the user does not have the right to make the given change.

  If the `assigned_roles()` table has any unscoped grants then we can jump to verifying that at
  least one of the grant rules allows for the change (see "Verifying Grants").

  If no unscoped roles/grants match the change or none of the unscoped grant rules allow the
  change then we try to find scoped roles for the change.

  ### 2. Match roles to the scope of the change

  The `Permissions.scope_resolver` attribute provides an implementation of the
  `#{Permissions.Scope}` behaviour. This allows for traversing the tree and finding the associated
  scope root entry for any node.

  With this we can match a change to a set of scoped roles and then verify their associated grants.

  ### 3. Look for applicable transient permissions

  If no scoped roles match the change then there might be a matching transient permission. We find
  these by supplying the list of Roles we have to the `Transient.for_roles/3` lookup function
  which will match the role's DDLX assignment id and the id of its scope root to the set of
  transient permissions available.

  For every transient permission we have access to, we can then verify the grants for the
  associated role.

  ### 4. Verifying Grants

  Grants can limit the allowed changes by:

  - They can limit the columns allowed. So e.g. you can `GRANT UPDATE (title) ON table TO role` to
    only allow `role` to update the title column of a table.

    With a grant of this style if you attempt to update any other column, the write will be rejected.

  - They can have an optional `CHECK` expression that tests the content of the change against some
    function and will reject the write if that check fails.

  ### 5. Allowing the write

  Because the permissions system is at the moment additive, if *any* of the grants succeeds then
  the write is allowed.

  If no role-grant pairs are found that match the change or the conditions on all the matching
  grants fail, then the write is denied.

  ### Special cases

  1. An update that moves a row between authentication scopes is treated like an update in the
  original scope and an insert in the new scope. The user must have permission for both the update
  and the (pseudo) insert for the change to be allowed.

  ## Filtering reads

  The `filter_read/2` function takes a `Permissions` and `Changes.Transaction` structs and filters
  the changes in the transaction according to the current permissions rules.

  The permissions verification process is the same as for verifying writes, except that the lookup
  in step 1 of that process always looks for permission to `:SELECT` on the relation in the
  change.

  ## Pending work

  1. `CHECK` clauses in GRANT statements are not validated at the moment
  2. Column subsetting in DDLX GRANT statements is ignored for the read path
  """
  require Logger

  defstruct [:source, :roles, :auth, :scopes, :scope_resolver, transient_lut: Transient]

  defmodule RoleGrant do
    # links a role to its corresponding grant
    defstruct [:role, :grant]

    @type t() :: %__MODULE__{
            grant: Grant.t(),
            role: Role.t()
          }
  end

  @type change() :: Changes.change()
  @type lsn() :: Electric.Postgres.Lsn.t()
  @type mode() :: :read | :write
  @type relation() :: Electric.Postgres.relation()
  @type privilege() :: :INSERT | :UPDATE | :DELETE | :SELECT
  @type grant_permission() :: {relation(), privilege()}
  @type assigned_roles() :: %{unscoped: [RoleGrant.t()], scoped: [RoleGrant.t()]}
  @type compiled_role() :: %{grant_permission() => assigned_roles()}

  @type empty() :: %__MODULE__{
          auth: Auth.t(),
          transient_lut: Transient.lut(),
          scope_resolver: Scope.t()
        }
  @type t() :: %__MODULE__{
          source: %{grants: [%SatPerms.Grant{}], roles: [%SatPerms.Role{}]} | nil,
          roles: compiled_role(),
          auth: Auth.t(),
          transient_lut: Transient.lut(),
          scope_resolver: Scope.t()
        }

  @doc """
  Configure a new empty permissions configuration with the given auth token, scope resvolver and
  (optionally) a transient permissions lookup table name.

  Use `update/3` to add actual role and grant information.

  Arguments:

  - `auth` is the `#{Auth}` struct received from the connection auth
  - `scope_resolver` is an implementation of the `Permissions.Scope` behaviour in the
    form `{module, term}`
  - `transient_lut` (default: `#{Transient}`) is the name of the ETS table holding active
    transient permissions
  """
  @spec new(Auth.t(), Scope.t(), Transient.lut()) :: empty()
  def new(%Auth{} = auth, {_, _} = scope_resolver, transient_lut_name \\ Transient) do
    %__MODULE__{
      auth: auth,
      scope_resolver: scope_resolver,
      transient_lut: Transient.table_ref!(transient_lut_name)
    }
  end

  @doc """
  Build a permissions struct that can be used to filter changes from the replication stream.

  Arguments:

  - `grants` should be a list of `%SatPerms.Grant{}` protobuf structs
  - `roles` should be a list of `%SatPerms.Role{}` protobuf structs

  """
  @spec update(empty() | t(), [%SatPerms.Grant{}], [%SatPerms.Role{}]) :: t()
  def update(%__MODULE__{} = perms, grants, roles) do
    assigned_roles = build_roles(roles, perms.auth)

    role_grants =
      assigned_roles
      |> Stream.map(&{&1, Role.matching_grants(&1, grants)})
      |> Stream.reject(fn {_role, grants} -> Enum.empty?(grants) end)
      |> Stream.map(&build_grants/1)
      |> Stream.flat_map(&invert_role_lookup/1)
      |> Enum.group_by(&elem(&1, 0), &elem(&1, 1))
      |> Map.new(&classify_roles/1)

    %{
      perms
      | source: %{grants: grants, roles: roles},
        roles: role_grants,
        scopes: compile_scopes(assigned_roles)
    }
  end

  defp build_roles(roles, auth) do
    roles
    |> Enum.map(&Role.new/1)
    |> add_authenticated(auth)
    |> add_anyone()
  end

  # For every `{table, privilege}` tuple we have a set of roles that the current user has.
  # If any of those roles are global, then it's equvilent to saying that the user can perform
  # `privilege` on `table` no matter what the scope. This function analyses the roles for a
  # given `{table, privilege}` and makes that test efficient by allowing for prioritising the
  # unscoped grant test.
  defp classify_roles({grant_perm, role_grants}) do
    {scoped, unscoped} =
      Enum.split_with(role_grants, &Role.has_scope?(&1.role))

    {grant_perm, %{scoped: scoped, unscoped: unscoped}}
  end

  # expand the grants into a list of `{{relation, privilege}, [%RoleGrant{}]}`
  # so that we can create a LUT of table and required privilege to role
  defp invert_role_lookup({role, grants}) do
    Stream.flat_map(grants, fn grant ->
      Enum.map(grant.privileges, &{{grant.table, &1}, %RoleGrant{grant: grant, role: role}})
    end)
  end

  defp build_grants({role, grants}) do
    {role, Enum.map(grants, &Grant.new/1)}
  end

  defp compile_scopes(roles) do
    roles
    |> Stream.filter(&Role.has_scope?/1)
    |> Stream.map(&elem(&1.scope, 0))
    |> Enum.uniq()
  end

  @spec filter_read(t(), Changes.Transaction.t()) :: Changes.Transaction.t()
  def filter_read(%__MODULE__{} = perms, %Changes.Transaction{changes: changes} = tx) do
    %{tx | changes: Enum.filter(changes, &validate_read(&1, perms, tx.lsn))}
  end

  defp validate_read(change, perms, lsn) do
    if role_grants = Map.get(perms.roles, {change.relation, :SELECT}) do
      role_grant_for_change(role_grants, perms, change, lsn, :read)
    end
  end

  @doc """
  Verify that all the writes in a transaction from satellite are allowed given the user's
  permissions.
  """
  @spec validate_write(t(), Changes.Transaction.t()) :: :ok | {:error, String.t()}
  def validate_write(%__MODULE__{} = perms, %Changes.Transaction{} = tx) do
    tx.changes
    |> Enum.flat_map(&expand_change(&1, perms))
    |> verify_all_writes(perms, tx.lsn)
  end

  defp expand_change(%Changes.UpdatedRecord{} = change, perms) do
    if modifies_scope_fk?(change, perms) do
      # expand an update that modifies a foreign key into the original update plus a
      # pseudo-insert into the scope defined by the updated foreign key
      insert = %Changes.NewRecord{relation: change.relation, record: change.record}
      [change, insert]
    else
      [change]
    end
  end

  defp expand_change(change, _perms) do
    [change]
  end

  defp modifies_scope_fk?(change, perms) do
    Enum.any?(perms.scopes, &Scope.modifies_fk?(perms.scope_resolver, &1, change))
  end

  defp verify_all_writes(changes, perms, lsn) do
    Enum.reduce_while(changes, :ok, fn change, :ok ->
      case validate_write(change, perms, lsn) do
        {:error, _} = error ->
          {:halt, error}

        %{role: role, grant: grant} = _role_grant ->
          Logger.debug(
            "role #{inspect(role)} grants #{inspect(grant)} permission for #{inspect(change)}"
          )

          {:cont, :ok}
      end
    end)
  end

  @spec validate_write(change(), t(), lsn()) :: RoleGrant.t() | {:error, String.t()}
  defp validate_write(change, perms, lsn) do
    action = required_permission(change)

    role_grant =
      perms.roles
      |> Map.get(action)
      |> role_grant_for_change(perms, change, lsn, :write)

    role_grant || permission_error(action)
  end

  @spec role_grant_for_change(nil, t(), change(), lsn(), mode()) :: nil
  defp role_grant_for_change(nil, _perms, _change, _lsn, _mode) do
    nil
  end

  @spec role_grant_for_change(assigned_roles(), t(), change(), lsn(), mode()) ::
          RoleGrant.t() | nil
  defp role_grant_for_change(grants, perms, change, lsn, mode) do
    %{scoped: scoped_role_grants, unscoped: unscoped_role_grants} = grants

    validate_change_against_grants(unscoped_role_grants, change, mode) ||
      match_scoped_role_to_change(scoped_role_grants, perms, change, lsn, mode)
  end

  @spec match_scoped_role_to_change([RoleGrant.t()], t(), change(), lsn(), mode()) ::
          RoleGrant.t() | nil
  defp match_scoped_role_to_change(role_grants, perms, change, lsn, mode) do
    # find roles that are valid for the scope of the change
    role_grants_in_scope = role_grants_in_scope(role_grants, perms.scope_resolver, change)

    validate_change_against_grants(role_grants_in_scope, change, mode) ||
      transient_permission_for_change(role_grants, perms, change, lsn, mode)
  end

  @spec transient_permission_for_change([RoleGrant.t()], t(), change(), lsn(), mode()) ::
          RoleGrant.t() | nil
  defp transient_permission_for_change(role_grants, perms, change, lsn, mode) do
    role_grants
    |> Transient.for_roles(lsn, perms.transient_lut)
    |> Enum.flat_map(fn {role_grant, %Transient{target_relation: relation, target_id: id} = tdp} ->
      if change_in_scope?(perms.scope_resolver, relation, id, change) do
        Logger.debug(fn ->
          "Using transient permission #{inspect(tdp)} for #{inspect(change)}"
        end)

        [role_grant]
      else
        []
      end
    end)
    |> validate_change_against_grants(change, mode)
  end

  @spec validate_change_against_grants([RoleGrant.t()], change(), mode()) ::
          RoleGrant.t() | nil
  defp validate_change_against_grants(role_grants, change, :write) do
    role_grants
    |> Enum.find(fn %{grant: grant} ->
      # ensure that change is compatible with grant conditions
      # note that we're allowing the change if *any* grant allows it
      change_matches_columns?(grant, change) && change_passes_check?(grant, change)
    end)
  end

  defp validate_change_against_grants(role_grants, change, :read) do
    role_grants
    |> Enum.find(fn %{grant: grant} ->
      change_passes_check?(grant, change)
    end)
  end

  defp change_matches_columns?(grant, %Changes.NewRecord{} = insert) do
    Grant.columns_valid?(grant, Map.keys(insert.record))
  end

  defp change_matches_columns?(grant, %Changes.UpdatedRecord{} = update) do
    Grant.columns_valid?(grant, update.changed_columns)
  end

  defp change_matches_columns?(_grant, _deleted_record) do
    true
  end

  defp change_passes_check?(%{check: nil}, _change) do
    true
  end

  defp change_passes_check?(_grant, _change) do
    # TODO: test change against check function
    true
  end

  # find roles that apply for the given change. use the precompiled
  # permissions to quickly filter any roles that don't have the required
  # privilege.
  #
  # this only runs against scoped-only roles because if we found a global role
  # we won't even get here
  defp role_grants_in_scope(role_grants, scope_resolv, change) do
    Enum.filter(role_grants, fn
      %{role: %{scope: {scope_table, scope_id}}} ->
        # filter out roles whose scope doesn't match
        #   - lookup their root id from the change
        #   - then reject roles that don't match the {table, pk_id}

        change_in_scope?(scope_resolv, scope_table, scope_id, change)
    end)
  end

  defp change_in_scope?(scope_resolver, scope_relation, scope_id, change) do
    case Scope.scope_id!(scope_resolver, scope_relation, change) do
      {:ok, id} -> scope_id == id
      # an {:error, _} response here means the change doesn't belong in the scope -- transient
      # runtime errors raise
      {:error, _reason} -> false
    end
  end

  defp add_anyone(roles) do
    [%Role.Anyone{} | roles]
  end

  defp add_authenticated(roles, %Auth{user_id: nil}) do
    roles
  end

  defp add_authenticated(roles, %Auth{user_id: user_id}) do
    [%Role.Authenticated{user_id: user_id} | roles]
  end

  defp required_permission(%change{relation: relation}) do
    case change do
      Changes.NewRecord -> {relation, :INSERT}
      Changes.UpdatedRecord -> {relation, :UPDATE}
      Changes.DeletedRecord -> {relation, :DELETE}
    end
  end

  defp permission_error({relation, privilege}) do
    action =
      case privilege do
        :INSERT -> "INSERT INTO "
        :DELETE -> "DELETE FROM "
        :UPDATE -> "UPDATE "
      end

    {:error,
     "user does not have permission to " <>
       action <> Electric.Utils.inspect_relation(relation)}
  end
end
